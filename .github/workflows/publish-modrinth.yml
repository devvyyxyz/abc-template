name: Publish datapack to Modrinth

# Triggers: tag pushes (v*), release published, or manual dispatch (with inputs)
on:
  push:
    tags:
      - 'v*'
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      datapack_path:
        description: 'Path to the datapack directory (relative to repo root). If blank the workflow will try to auto-detect.'
        required: false
        default: ''
      game_versions:
        description: 'Comma-separated game versions (e.g. 1.20.1,1.19.4)'
        required: false
        default: '1.20.1'
      loaders:
        description: 'Comma-separated loaders (for datapacks use "data")'
        required: false
        default: 'data'

jobs:
  publish:
    name: Build and publish datapack to Modrinth
    runs-on: ubuntu-latest
    env:
      MODRINTH_API_TOKEN: ${{ secrets.MODRINTH_API_TOKEN }}
      MODRINTH_PROJECT_ID: ${{ secrets.MODRINTH_PROJECT_ID }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Show repo root (debug)
        run: |
          echo "Repository tree (top 4 levels):"
          find . -maxdepth 4 -not -path './.git*' -print | sed 's|^\./||' || true

      - name: Set inputs
        id: inputs
        run: |
          DATAPACK_INPUT="${{ github.event.inputs.datapack_path || '' }}"
          GAME_VERSIONS="${{ github.event.inputs.game_versions || '1.20.1' }}"
          LOADERS="${{ github.event.inputs.loaders || 'data' }}"
          echo "datapack_input=$DATAPACK_INPUT" >> $GITHUB_OUTPUT
          echo "game_versions=$GAME_VERSIONS" >> $GITHUB_OUTPUT
          echo "loaders=$LOADERS" >> $GITHUB_OUTPUT

      - name: Auto-detect datapack path (if needed)
        id: detect
        run: |
          set -euo pipefail
          INPUT="${{ steps.inputs.outputs.datapack_input }}"
          # If explicit path provided and exists, use it
          if [ -n "$INPUT" ] && [ -d "$INPUT" ]; then
            echo "Using provided datapack path: $INPUT"
            echo "datapack_path=$INPUT" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Prefer pack.mcmeta (typical datapack indicator)
          mapfile -d '' pmfiles < <(find . -type f -name 'pack.mcmeta' -print0 || true)
          if [ "${#pmfiles[@]}" -eq 1 ]; then
            p="${pmfiles[0]}"
            dir="$(dirname "$p")"
            dir="${dir#./}"
            echo "Auto-detected datapack path from pack.mcmeta: $dir"
            echo "datapack_path=$dir" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "${#pmfiles[@]}" -gt 1 ]; then
            echo "Multiple pack.mcmeta files found:"
            for f in "${pmfiles[@]}"; do echo " - ${f#./}"; done
            echo "Please provide datapack_path input to disambiguate."
            exit 1
          fi

          # Fallback: find a directory that contains a 'data' folder (typical datapack layout)
          mapfile -d '' candidates < <(find . -type d -path '*/data' -print0 || true)
          if [ "${#candidates[@]}" -gt 0 ]; then
            first="${candidates[0]}"
            root="${first%/data}"
            root="${root#./}"
            # if root is empty, it means the repository root is the datapack
            if [ -z "$root" ]; then root="."; fi
            echo "Auto-detected datapack path by finding 'data' folder: $root"
            echo "datapack_path=$root" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "ERROR: could not find pack.mcmeta or a 'data' folder to auto-detect a datapack."
          echo "If your datapack is in a non-standard location, set the 'datapack_path' input when running the workflow."
          exit 1

      - name: Determine version string
        id: version
        run: |
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            RAW_TAG="${GITHUB_REF#refs/tags/}"
            VERSION="${RAW_TAG#v}"
          else
            VERSION="$(git rev-parse --short HEAD)"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Create zip of datapack
        id: package
        run: |
          set -euo pipefail
          DATAPACK_PATH="${{ steps.detect.outputs.datapack_path }}"
          echo "Datapack path to package: $DATAPACK_PATH"
          if [ -z "$DATAPACK_PATH" ] || [ ! -d "$DATAPACK_PATH" ]; then
            echo "ERROR: datapack path '$DATAPACK_PATH' does not exist."
            exit 1
          fi

          # Ensure the zip filename contains no slashes (GITHUB_REPOSITORY is "owner/repo")
          REPO_SAFE="${GITHUB_REPOSITORY//\//-}"
          VERSION="${{ steps.version.outputs.version }}"
          ZIP_NAME="${REPO_SAFE}-datapack-${VERSION}.zip"

          # Create zip in the workspace root to avoid writing outside the workspace
          rm -f "$GITHUB_WORKSPACE/$ZIP_NAME"
          (cd "$DATAPACK_PATH" && zip -r "$GITHUB_WORKSPACE/$ZIP_NAME" . -x "*.git*" ) || { echo "zip failed"; exit 1; }
          echo "zip=$ZIP_NAME" >> $GITHUB_OUTPUT

      - name: Publish to Modrinth
        env:
          MODRINTH_API_TOKEN: ${{ secrets.MODRINTH_API_TOKEN }}
          MODRINTH_PROJECT_ID: ${{ secrets.MODRINTH_PROJECT_ID }}
        run: |
          set -euo pipefail

          # Correct v2 endpoint for create-version
          API_URL="https://api.modrinth.com/v2/version"

          ZIP_NAME="${{ steps.package.outputs.zip }}"
          ZIP_PATH="$GITHUB_WORKSPACE/$ZIP_NAME"
          if [ ! -f "$ZIP_PATH" ]; then
            echo "ERROR: zip file not found at $ZIP_PATH"
            exit 1
          fi

          VERSION="${{ steps.version.outputs.version }}"
          GAME_VERSIONS_RAW="${{ steps.inputs.outputs.game_versions }}"
          LOADERS_RAW="${{ steps.inputs.outputs.loaders }}"

          # Build changelog (reuse same logic as before)
          if [ -f CHANGELOG.md ]; then
            CHANGELOG="$(cat CHANGELOG.md)"
          else
            if [ -f "${{ steps.detect.outputs.datapack_path }}/pack.mcmeta" ]; then
              DESC="$(jq -r '.pack.description // empty' "${{ steps.detect.outputs.datapack_path }}/pack.mcmeta" 2>/dev/null || true)"
              if [ -n "$DESC" ]; then
                CHANGELOG="$DESC"
              else
                CHANGELOG="Automated upload from GitHub Actions for version ${VERSION}"
              fi
            else
              CHANGELOG="Automated upload from GitHub Actions for version ${VERSION}"
            fi
          fi

          # Normalize token: allow secret to be stored either with or without leading "mrp_"
          TOKEN="${MODRINTH_API_TOKEN}"
          if [[ "$TOKEN" != mrp_* ]]; then
            TOKEN="mrp_${TOKEN}"
          fi

          # Build JSON arrays robustly and output compact JSON (-c)
          GAME_JSON="$(printf '%s' "$GAME_VERSIONS_RAW" | jq -R -s 'split(",") | map(.|gsub("^\\s+|\\s+$";""))')"
          LOADERS_JSON="$(printf '%s' "$LOADERS_RAW" | jq -R -s 'split(",") | map(.|gsub("^\\s+|\\s+$";""))')"

          # Use the repository name dynamically for the version "name"
          REPO_NAME="${GITHUB_REPOSITORY##*/}"

          # Build the 'data' JSON payload required by Modrinth.
          # NOTE: dependencies is an empty array here per your fix.
          # Add the required "featured" field (boolean). Default false for non-featured uploads.
          DATA_JSON="$(jq -c -n \
            --arg project_id "${MODRINTH_PROJECT_ID}" \
            --arg name "${REPO_NAME} ${VERSION}" \
            --arg version_number "${VERSION}" \
            --arg changelog "${CHANGELOG}" \
            --argjson game_versions "${GAME_JSON}" \
            --argjson loaders "${LOADERS_JSON}" \
            '{
              project_id: $project_id,
              name: $name,
              version_number: $version_number,
              changelog: $changelog,
              changelog_type: "markdown",
              game_versions: $game_versions,
              loaders: $loaders,
              dependencies: [],
              file_parts: ["file"],
              primary_file: "file",
              version_type: "release",
              featured: false
            }')"

          # Debug print to help diagnose API parsing errors in logs
          echo "DATA_JSON: $DATA_JSON" >&2

          echo "Uploading ${ZIP_NAME} to Modrinth project ${MODRINTH_PROJECT_ID} as version ${VERSION}..."
          # Send the 'data' part explicitly as application/json so arrays are parsed correctly server-side
          RESPONSE="$(curl -sS -X POST \
            -H "Authorization: ${TOKEN}" \
            -F "data=${DATA_JSON};type=application/json" \
            -F "file=@${ZIP_PATH}" \
            "${API_URL}" || true)"

          echo "Response: $RESPONSE"
          if echo "$RESPONSE" | grep -qi '"error"'; then
            echo "Modrinth API returned an error."
            exit 1
          fi

      - name: Success message
        if: success()
        run: echo "Datapack uploaded to Modrinth successfully."
